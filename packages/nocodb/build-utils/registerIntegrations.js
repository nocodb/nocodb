const path = require('path');
const fs = require('fs').promises;
const { glob } = require('glob');

const capitalize = (str) => str.charAt(0).toUpperCase() + str.slice(1);

const camelize = (s) => s.replace(/-./g, (x) => x[1].toUpperCase());

const prepareComponentName = (name) => capitalize(camelize(name));

async function registerIntegrations(EE = false) {
  const integrationRoot = EE ? 'src/ee/integrations' : 'src/integrations';

  const files = await glob(`${integrationRoot}/**/*`, {
    ignore: [
      `${integrationRoot}/*`,
      `${integrationRoot}/*/*`,
      `${integrationRoot}/ai/module/**/*`,
    ],
    cwd: `${__dirname}/../`,
    absolute: true,
  });

  if (!files || !files.length) {
    return;
  }

  files.sort((a, b) => a.localeCompare(b));

  const availableIntegrations = [];
  const availableTypes = [];

  for (const file of files) {
    const integrationType = file
      .replace(/.*integrations\//, '')
      ?.split('/')?.[0];

    if (!integrationType) continue;

    if (!availableTypes.includes(integrationType)) {
      availableTypes.push(integrationType);
    }

    const subTypeRegex = new RegExp(`.*integrations/${integrationType}/`);
    const integrationSubType = file.replace(subTypeRegex, '')?.split('/')?.[0];

    if (!integrationSubType) continue;

    let integration = availableIntegrations.find((el) => {
      return integrationType === el.type && integrationSubType === el.subType;
    });

    if (!integration) {
      integration = {
        type: integrationType,
        subType: integrationSubType,
      };
      availableIntegrations.push(integration);
    }

    if (file.includes('entry')) {
      const filename = path.basename(file).replace('.ts', '');
      integration.entry = `~/integrations/${integrationType}/${integrationSubType}/${filename}`;
    } else if (file.includes('form')) {
      const filename = path.basename(file).replace('.ts', '');
      integration.form = `~/integrations/${integrationType}/${integrationSubType}/${filename}`;
    } else if (file.includes('manifest')) {
      const filename = path.basename(file).replace('.ts', '');
      integration.manifest = `~/integrations/${integrationType}/${integrationSubType}/${filename}`;
    }
  }

  // Generate the content for integrations.ts
  let integrationsEntry = `/*
  This file is auto-generated by \`pnpm run registerIntegrations\`
  !!! Do not edit this file manually !!!
*/

import type { FormDefinition, IntegrationsType } from 'nocodb-sdk';
import type IntegrationWrapper from '~/integrations/integration.wrapper';

`;

  // Generate import statements for types
  for (const type of availableTypes) {
    integrationsEntry += `import ${prepareComponentName(
      type,
    )}CommonManifest from '~/integrations/${type}/${type}.manifest';\n`;
  }

  integrationsEntry += `\n`;

  // Generate import statements
  for (const integration of availableIntegrations) {
    if (integration.entry) {
      integrationsEntry += `import ${prepareComponentName(
        integration.type,
      )}${prepareComponentName(integration.subType)}Entry from '${
        integration.entry
      }';\n`;
    }
    if (integration.form) {
      integrationsEntry += `import ${prepareComponentName(
        integration.type,
      )}${prepareComponentName(integration.subType)}Form from '${
        integration.form
      }';\n`;
    }
    if (integration.manifest) {
      integrationsEntry += `import ${prepareComponentName(
        integration.type,
      )}${prepareComponentName(integration.subType)}Manifest from '${
        integration.manifest
      }';\n`;
    }
  }

  if (availableIntegrations.length) {
    integrationsEntry += `\nexport default [\n`;

    // Generate integration objects
    for (const integration of availableIntegrations) {
      integrationsEntry += `  {\n`;
      integrationsEntry += `    type: '${integration.type}',\n`;
      integrationsEntry += `    subType: '${integration.subType}',\n`;
      if (integration.entry) {
        integrationsEntry += `    wrapper: ${prepareComponentName(
          integration.type,
        )}${prepareComponentName(integration.subType)}Entry,\n`;
      }
      if (integration.form) {
        integrationsEntry += `    form: ${prepareComponentName(
          integration.type,
        )}${prepareComponentName(integration.subType)}Form,\n`;
      }
      if (integration.manifest) {
        integrationsEntry += `    meta: {
      ...${prepareComponentName(integration.type)}CommonManifest,
      ...${prepareComponentName(integration.type)}${prepareComponentName(
          integration.subType,
        )}Manifest,
    },\n`;
      }
      integrationsEntry += `  },\n`;
    }

    integrationsEntry += `] as {
  type: IntegrationsType;
  subType: string;
  form?: FormDefinition;
  wrapper?: typeof IntegrationWrapper;
  meta?: {
    title?: string;
    value?: string;
    icon?: string;
    description?: string;
    exposedEndpoints?: string[];
  };
}[];\n`;
  } else {
    integrationsEntry += `export default [] as {
  type: IntegrationsType;
  subType: string;
  form?: FormDefinition;
  wrapper?: typeof IntegrationWrapper;
  meta?: {
    title?: string;
    value?: string;
    icon?: string;
    description?: string;
    exposedEndpoints?: string[];
  };
}[];\n`;
  }

  // Write the generated content to integrations.ts
  await fs.writeFile(
    path.join(__dirname, '..', `${integrationRoot}/integrations.ts`),
    integrationsEntry,
  );

  console.log('integrations.ts has been generated successfully.');
}

registerIntegrations();
registerIntegrations(true);
