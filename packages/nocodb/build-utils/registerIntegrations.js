const path = require('path');
const fs = require('fs').promises;
const { glob } = require('glob');

const capitalize = (str) => str.charAt(0).toUpperCase() + str.slice(1);

async function registerIntegrations() {
  const files = await glob('src/integrations/**/*', {
    ignore: [
      'src/integrations/*',
      'src/integrations/*/*',
      'src/integrations/ai/module/**/*',
    ],
    cwd: `${__dirname}/../`,
    absolute: true,
  });

  files.sort((a, b) => a.localeCompare(b));

  const availableIntegrations = [];
  const availableTypes = [];

  for (const file of files) {
    const integrationType = file
      .replace(/.*integrations\//, '')
      ?.split('/')?.[0];

    if (!integrationType) continue;

    if (!availableTypes.includes(integrationType)) {
      availableTypes.push(integrationType);
    }

    const subTypeRegex = new RegExp(`.*integrations/${integrationType}/`);
    const integrationSubType = file.replace(subTypeRegex, '')?.split('/')?.[0];

    if (!integrationSubType) continue;

    let integration = availableIntegrations.find((el) => {
      return integrationType === el.type && integrationSubType === el.subType;
    });

    if (!integration) {
      integration = {
        type: integrationType,
        subType: integrationSubType,
      };
      availableIntegrations.push(integration);
    }

    if (file.includes('entry')) {
      const filename = path.basename(file).replace('.ts', '');
      integration.entry = `~/integrations/${integrationType}/${integrationSubType}/${filename}`;
    } else if (file.includes('form')) {
      const filename = path.basename(file).replace('.ts', '');
      integration.form = `~/integrations/${integrationType}/${integrationSubType}/${filename}`;
    } else if (file.includes('manifest')) {
      const filename = path.basename(file).replace('.ts', '');
      integration.manifest = `~/integrations/${integrationType}/${integrationSubType}/${filename}`;
    }
  }

  // Generate the content for integrations.ts
  let integrationsEntry = `/*
  This file is auto-generated by \`pnpm run registerIntegrations\`
  !!! Do not edit this file manually !!!
*/

import type { FormDefinition, IntegrationsType } from 'nocodb-sdk';
import type IntegrationWrapper from '~/integrations/integration.wrapper';

`;

  // Generate import statements for types
  for (const type of availableTypes) {
    integrationsEntry += `import ${capitalize(
      type,
    )}CommonManifest from '~/integrations/${type}/${type}.manifest';\n`;
  }

  integrationsEntry += `\n`;

  // Generate import statements
  for (const integration of availableIntegrations) {
    if (integration.entry) {
      integrationsEntry += `import ${capitalize(integration.type)}${capitalize(
        integration.subType,
      )}Entry from '${integration.entry}';\n`;
    }
    if (integration.form) {
      integrationsEntry += `import ${capitalize(integration.type)}${capitalize(
        integration.subType,
      )}Form from '${integration.form}';\n`;
    }
    if (integration.manifest) {
      integrationsEntry += `import ${capitalize(integration.type)}${capitalize(
        integration.subType,
      )}Manifest from '${integration.manifest}';\n`;
    }
  }

  integrationsEntry += `\nexport default [\n`;

  // Generate integration objects
  for (const integration of availableIntegrations) {
    integrationsEntry += `  {\n`;
    integrationsEntry += `    type: '${integration.type}',\n`;
    integrationsEntry += `    subType: '${integration.subType}',\n`;
    if (integration.entry) {
      integrationsEntry += `    wrapper: ${capitalize(
        integration.type,
      )}${capitalize(integration.subType)}Entry,\n`;
    }
    if (integration.form) {
      integrationsEntry += `    form: ${capitalize(
        integration.type,
      )}${capitalize(integration.subType)}Form,\n`;
    }
    if (integration.manifest) {
      integrationsEntry += `    meta: {
      ...${capitalize(integration.type)}CommonManifest,
      ...${capitalize(integration.type)}${capitalize(
        integration.subType,
      )}Manifest,
    },\n`;
    }
    integrationsEntry += `  },\n`;
  }

  integrationsEntry += `] as {
  type: IntegrationsType;
  subType: string;
  form?: FormDefinition;
  wrapper?: typeof IntegrationWrapper;
  meta?: {
    title?: string;
    value?: string;
    icon?: string;
    description?: string;
    exposedEndpoints?: string[];
  };
}[];\n`;

  // Write the generated content to integrations.ts
  await fs.writeFile(
    path.join(__dirname, '..', 'src/integrations/integrations.ts'),
    integrationsEntry,
  );

  console.log('integrations.ts has been generated successfully.');
}

registerIntegrations();
