import {
  AuditOperationSubTypes,
  isLinksOrLTAR,
  isLinkV2,
  isMMOrMMLike,
  RelationTypes,
} from 'nocodb-sdk';
import type { NcContext, NcRequest } from 'nocodb-sdk';
import type { Column, LinkToAnotherRecordColumn } from '~/models';
import type { IBaseModelSqlV2 } from '~/db/IBaseModelSqlV2';
import type { Knex } from 'knex';
import { Model } from '~/models';
import { RelationUpdateWebhookHandler } from '~/db/relation-update-webhook-handler';
import { NcError } from '~/helpers/catchError';
import {
  _wherePk,
  getCompositePkValue,
  getOppositeRelationType,
} from '~/helpers/dbHelpers';
import { getTargetTableRelColumn } from '~/helpers';

interface AuditUpdateLog {
  pkValue?: Record<string, any>;
  rowId: unknown;
  refRowId?: unknown;
  displayValue?: unknown;
  refDisplayValue?: unknown;
  opSubType:
    | AuditOperationSubTypes.LINK_RECORD
    | AuditOperationSubTypes.UNLINK_RECORD;
  type: RelationTypes;
  direction: 'parent_child' | 'child_parent';
}

interface AuditUpdateObj extends AuditUpdateLog {
  columnTitle: string;
  refColumnTitle?: string;
  columnId: string;
  req: NcRequest;
  model: Model;
  refModel?: Model;
}

export class RelationManager {
  constructor(
    private relationContext: {
      baseModel: IBaseModelSqlV2;
      relationColumn: Column<any>;
      relationColOptions: LinkToAnotherRecordColumn;
      childTn: string | Knex.Raw<any>;
      childColumn: Column<any>;
      childTable: Model;
      childBaseModel: IBaseModelSqlV2;
      parentTn: string | Knex.Raw<any>;
      parentColumn: Column<any>;
      parentTable: Model;
      parentBaseModel: IBaseModelSqlV2;
      childId: any;
      parentId: any;
      parentContext: NcContext;
      childContext: NcContext;
      mmContext: NcContext;
      refContext: NcContext;
    },
  ) {}

  protected auditUpdateObj: AuditUpdateLog[] = [];

  getRelationContext() {
    return this.relationContext;
  }

  // for M2M and Belongs to relation, the relation stored in column option is reversed
  // parent become child, child become parent from the viewpoint of col options
  static isRelationReversed(
    relationColumn: Column<any>,
    colOptions: LinkToAnotherRecordColumn,
  ) {
    const isBelongsTo =
      colOptions.type === RelationTypes.BELONGS_TO || relationColumn.meta?.bt;
    return (
      isLinkV2(relationColumn) ||
      isBelongsTo ||
      colOptions.type === RelationTypes.MANY_TO_MANY
    );
  }

  static async getRelationManager(
    baseModel: IBaseModelSqlV2,
    colId: string,
    id: {
      rowId: any;
      childId: any;
    },
  ) {
    await baseModel.model.getColumns(baseModel.context);
    const column = baseModel.model.columnsById[colId];

    if (!column || !isLinksOrLTAR(column.uidt)) NcError.fieldNotFound(colId);

    const colOptions = await column.getColOptions<LinkToAnotherRecordColumn>(
      baseModel.context,
    );

    const { parentContext, childContext, refContext, mmContext } =
      await colOptions.getParentChildContext(baseModel.context);

    const childColumn = await colOptions.getChildColumn(childContext);
    const parentColumn = await colOptions.getParentColumn(parentContext);

    const parentTable = await parentColumn.getModel(parentContext);
    const childTable = await childColumn.getModel(childContext);

    await childTable.getColumns(childContext);
    await parentTable.getColumns(parentContext);

    const parentBaseModel = await Model.getBaseModelSQL(parentContext, {
      model: parentTable,
      dbDriver: baseModel.dbDriver,
    });

    const childBaseModel = await Model.getBaseModelSQL(childContext, {
      dbDriver: baseModel.dbDriver,
      model: childTable,
    });

    return new RelationManager({
      baseModel,
      relationColumn: column,
      relationColOptions: colOptions,
      childTn: childBaseModel.getTnPath(childTable),
      childColumn,
      childTable,
      childBaseModel,
      parentTn: parentBaseModel.getTnPath(parentTable),
      parentColumn,
      parentTable,
      parentBaseModel,
      childId:
        // in bt or mm child id and row id is swapped
        // due to table definition
        RelationManager.isRelationReversed(column, colOptions)
          ? id.rowId
          : id.childId,
      parentId: RelationManager.isRelationReversed(column, colOptions)
        ? id.childId
        : id.rowId,
      parentContext,
      childContext,
      refContext,
      mmContext,
    });
  }

  async getHmOrOoChildRow() {
    const {
      childBaseModel: baseModel,
      childTn,
      childColumn,
      childTable,
      childId,
    } = this.relationContext;
    return await baseModel.execAndParse(
      baseModel
        .dbDriver(childTn)
        .select(
          ...new Set(
            [childColumn, ...childTable.primaryKeys].map(
              (col) => `${childTable.table_name}.${col.column_name}`,
            ),
          ),
        )
        .where(_wherePk(childTable.primaryKeys, childId)),
      null,
      { raw: true, first: true },
    );
  }

  async getLinkV2RelatedRow() {
    const {
      childTable,
      childBaseModel,
      childTn,
      childColumn,
      childId,
      parentBaseModel,
      parentTn,
      parentColumn,
      relationColOptions,
      mmContext,
    } = this.relationContext;

    const vChildCol = await relationColOptions.getMMChildColumn(mmContext);
    const vParentCol = await relationColOptions.getMMParentColumn(mmContext);
    const vTable = await relationColOptions.getMMModel(mmContext);

    const assocBaseModel = await Model.getBaseModelSQL(mmContext, {
      model: vTable,
      dbDriver: childBaseModel.dbDriver,
    });

    const vTn = assocBaseModel.getTnPath(vTable);

    // Get related records from parent table through junction table
    return await parentBaseModel.execAndParse(
      parentBaseModel
        .dbDriver(parentTn)
        .select(`${parentTn}.*`)
        .join(
          vTn,
          `${vTn}.${vParentCol.column_name}`,
          `${parentTn}.${parentColumn.column_name}`,
        )
        .where({
          [`${vTn}.${vChildCol.column_name}`]: childBaseModel
            .dbDriver(childTn)
            .select(childColumn.column_name)
            .where(_wherePk(childTable.primaryKeys, childId))
            .first(),
        }),
      null,
      { raw: true },
    );
  }

  async getHmOrOoChildLinkedWithParent() {
    const {
      childBaseModel: baseModel,
      childTn,
      parentTn,
      childColumn,
      parentColumn,
      parentTable,
      parentId,
    } = this.relationContext;
    return await baseModel.execAndParse(
      baseModel.dbDriver(childTn).where({
        [childColumn.column_name]: baseModel.dbDriver.from(
          baseModel
            .dbDriver(parentTn)
            .select(parentColumn.column_name)
            .where(_wherePk(parentTable.primaryKeys, parentId))
            .first()
            .as('___cn_alias'),
        ),
      }),
      null,
      { raw: true, first: true },
    );
  }

  async addChild(params: {
    onlyUpdateAuditLogs?: boolean;
    prevData?: Record<string, any>;
    req: any;
  }) {
    const {
      relationColOptions: colOptions,
      baseModel,
      parentBaseModel,
      parentColumn,
      parentTable,
      parentTn,
      childBaseModel,
      childColumn,
      childTable,
      childTn,

      childId,
      parentId,
      mmContext,
      relationColumn,
    } = this.relationContext;

    const isMMLike = isMMOrMMLike(this.relationContext.relationColumn);

    const { onlyUpdateAuditLogs, req } = params;
    if (onlyUpdateAuditLogs && colOptions.type !== RelationTypes.BELONGS_TO) {
      return await this.handleOnlyUpdateAudit(params);
    }

    const webhookHandler = await RelationUpdateWebhookHandler.beginUpdate(
      {
        childBaseModel,
        parentBaseModel,
        user: req.user,
        ignoreWebhook: req.query?.ignoreWebhook,
      },
      {
        parent: parentId,
        child: childId,
      },
    );

    const relationType = isMMLike
      ? RelationTypes.MANY_TO_MANY
      : colOptions.type;

    switch (relationType) {
      case RelationTypes.MANY_TO_MANY:
        {
          const vChildCol = await colOptions.getMMChildColumn(mmContext);
          const vParentCol = await colOptions.getMMParentColumn(mmContext);
          const vTable = await colOptions.getMMModel(baseModel.context);

          const assocBaseModel = await Model.getBaseModelSQL(mmContext, {
            model: vTable,
            dbDriver: baseModel.dbDriver,
          });

          const vTn = assocBaseModel.getTnPath(vTable);
          // if relation type is Many to One / One to One, then remove the existing link
          if (
            [RelationTypes.MANY_TO_ONE, RelationTypes.ONE_TO_ONE].includes(
              colOptions.type as RelationTypes,
            )
          ) {
            // Get existing children linked to this parent
            const existingChildren = await this.getLinkV2RelatedRow();

            // Remove each existing child with proper audit logging
            for (const child of existingChildren) {
              // Create a new relation manager with the correct IDs for this relationship
              const relationManager = await RelationManager.getRelationManager(
                baseModel,
                this.relationContext.relationColumn.id,
                {
                  // in case of LinkToAnotherRecordV2, childId is the rowId
                  rowId: childId,
                  childId: getCompositePkValue(parentTable.primaryKeys, child),
                },
              );
              await relationManager.removeChild({ req });
              // merge audit logs
              this.auditUpdateObj.push(...relationManager.auditUpdateObj);
            }
          }

          // if relation type is One to Many / One to One, then remove any existing parent link
          if (
            [RelationTypes.ONE_TO_MANY, RelationTypes.ONE_TO_ONE].includes(
              colOptions.type as RelationTypes,
            )
          ) {
            const targetRelationColumn = await getTargetTableRelColumn(
              childBaseModel.context,
              relationColumn,
              parentTable,
            );
            const targetRelationManager =
              await RelationManager.getRelationManager(
                parentBaseModel,
                targetRelationColumn.id,
                {
                  // in case of LinkToAnotherRecordV2, childId is the rowId
                  rowId: parentId,
                  // provide a dummy value
                  childId: '',
                },
              );

            // Get existing children linked to this parent
            const existingChildren =
              await targetRelationManager.getLinkV2RelatedRow();

            // Remove each existing child with proper audit logging
            for (const child of existingChildren) {
              // Create a new relation manager with the correct IDs for this relationship
              const relationManager = await RelationManager.getRelationManager(
                parentBaseModel,
                targetRelationColumn.id,
                {
                  rowId: parentId,
                  childId: getCompositePkValue(childTable.primaryKeys, child),
                },
              );
              await relationManager.removeChild({ req });
              // merge audit logs
              this.auditUpdateObj.push(...relationManager.auditUpdateObj);
            }
          }

          if (baseModel.isSnowflake || baseModel.isDatabricks) {
            const parentPK = parentBaseModel
              .dbDriver(parentTn)
              .select(parentColumn.column_name)
              .where(_wherePk(parentTable.primaryKeys, parentId))
              .first();

            const childPK = childBaseModel
              .dbDriver(childTn)
              .select(childColumn.column_name)
              .where(_wherePk(childTable.primaryKeys, childId))
              .first();

            await baseModel.execAndParse(
              baseModel.dbDriver.raw(
                `INSERT INTO ?? (??, ??) SELECT (${parentPK.toQuery()}), (${childPK.toQuery()})`,
                [vTn, vParentCol.column_name, vChildCol.column_name],
              ) as any,
              null,
              { raw: true },
            );
          } else {
            await assocBaseModel.execAndParse(
              baseModel.dbDriver(vTn).insert({
                [vParentCol.column_name]: baseModel
                  .dbDriver(parentTn)
                  .select(parentColumn.column_name)
                  .where(_wherePk(parentTable.primaryKeys, parentId))
                  .first(),
                [vChildCol.column_name]: baseModel
                  .dbDriver(childTn)
                  .select(childColumn.column_name)
                  .where(_wherePk(childTable.primaryKeys, childId))
                  .first(),
              }),
              null,
              { raw: true },
            );
          }

          await parentBaseModel.updateLastModified({
            baseModel: parentBaseModel,
            model: parentTable,
            rowIds: [parentId],
            cookie: req,
            updatedColIds: [refTableLinkColumnId],
          });

          await parentBaseModel.broadcastLinkUpdates([parentId]);

          await childBaseModel.updateLastModified({
            baseModel: childBaseModel,
            model: childTable,
            rowIds: [childId],
            cookie: req,
            updatedColIds: [column.id],
          });

          await childBaseModel.broadcastLinkUpdates([childId]);
        }
        break;
      case RelationTypes.HAS_MANY:
        {
          const linkedHmRowObj = await this.getHmOrOoChildRow();

          const oldRowId = linkedHmRowObj
            ? linkedHmRowObj?.[childColumn?.column_name]
            : null;

          if (oldRowId) {
            await webhookHandler.addAffectedParentId(oldRowId);
            const [parentRelatedPkValue, childRelatedPkValue] =
              await baseModel.readOnlyPrimariesByPkFromModel([
                { model: childTable, id: childId },
                { model: parentTable, id: oldRowId },
              ]);

            this.auditUpdateObj.push({
              rowId: oldRowId as string,
              refRowId: childId,
              opSubType: AuditOperationSubTypes.UNLINK_RECORD,
              refDisplayValue: parentRelatedPkValue,
              displayValue: childRelatedPkValue,
              direction: 'parent_child',
              type: colOptions.type as RelationTypes,
            });

            this.auditUpdateObj.push({
              rowId: childId,
              refRowId: oldRowId as string,
              opSubType: AuditOperationSubTypes.UNLINK_RECORD,
              displayValue: parentRelatedPkValue,
              refDisplayValue: childRelatedPkValue,
              direction: 'child_parent',
              type: getOppositeRelationType(colOptions.type),
            });
            await parentBaseModel.updateLastModified({
              baseModel: parentBaseModel,
              model: parentTable,
              rowIds: [oldRowId],
              cookie: req,
              updatedColIds: [column.id],
            });
          }

          await childBaseModel.execAndParse(
            baseModel
              .dbDriver(childTn)
              .update({
                [childColumn.column_name]: baseModel.dbDriver.from(
                  baseModel
                    .dbDriver(parentTn)
                    .select(parentColumn.column_name)
                    .where(_wherePk(parentTable.primaryKeys, parentId))
                    .first()
                    .as('___cn_alias'),
                ),
              })
              .where(_wherePk(childTable.primaryKeys, childId)),
            null,
            { raw: true },
          );
          // await triggerAfterRemoveChild();

          await childBaseModel.updateLastModified({
            baseModel: childBaseModel,
            model: childTable,
            rowIds: [childId],
            cookie: req,
            updatedColIds: [refTableLinkColumnId],
          });

          await childBaseModel.broadcastLinkUpdates([childId]);

          await parentBaseModel.updateLastModified({
            baseModel: parentBaseModel,
            model: parentTable,
            rowIds: [parentId],
            cookie: req,
            updatedColIds: [column.id],
          });

          await parentBaseModel.broadcastLinkUpdates([parentId]);
        }
        break;
      case RelationTypes.BELONGS_TO:
        {
          const linkedHmRowObj = await this.getHmOrOoChildRow();

          const oldParentRowId = linkedHmRowObj
            ? linkedHmRowObj[childColumn.column_name]
            : null;
          if (oldParentRowId) {
            await webhookHandler.addAffectedParentId(oldParentRowId);
            const [parentRelatedPkValue, childRelatedPkValue] =
              await baseModel.readOnlyPrimariesByPkFromModel([
                { model: parentTable, id: oldParentRowId },
                { model: childTable, id: childId },
              ]);

            this.auditUpdateObj.push({
              rowId: oldParentRowId as string,
              refRowId: childId,
              opSubType: AuditOperationSubTypes.UNLINK_RECORD,
              displayValue: parentRelatedPkValue,
              refDisplayValue: childRelatedPkValue,
              direction: 'parent_child',
              type: colOptions.type as RelationTypes,
            });

            this.auditUpdateObj.push({
              rowId: childId,
              refRowId: oldParentRowId as string,
              opSubType: AuditOperationSubTypes.UNLINK_RECORD,
              displayValue: childRelatedPkValue,
              refDisplayValue: parentRelatedPkValue,
              direction: 'child_parent',
              type: getOppositeRelationType(colOptions.type),
            });

            await parentBaseModel.updateLastModified({
              baseModel: parentBaseModel,
              model: parentTable,
              rowIds: [oldParentRowId],
              cookie: req,
              updatedColIds: [
                (
                  await extractCorrespondingLinkColumn(childBaseModel.context, {
                    ltarColumn: column,
                    referencedTable: parentTable,
                  })
                )?.id,
              ],
            });
          }

          await childBaseModel.execAndParse(
            childBaseModel
              .dbDriver(childTn)
              .update({
                [childColumn.column_name]: baseModel.dbDriver.from(
                  baseModel
                    .dbDriver(parentTn)
                    .select(parentColumn.column_name)
                    .where(_wherePk(parentTable.primaryKeys, parentId))
                    .first()
                    .as('___cn_alias'),
                ),
              })
              .where(_wherePk(childTable.primaryKeys, childId)),
            null,
            { raw: true },
          );

          // await triggerAfterRemoveChild();
          await childBaseModel.updateLastModified({
            baseModel: childBaseModel,
            model: childTable,
            rowIds: [childId],
            cookie: req,
            updatedColIds: [column.id],
          });

          await childBaseModel.broadcastLinkUpdates([childId]);

          await parentBaseModel.updateLastModified({
            baseModel: parentBaseModel,
            model: parentTable,
            rowIds: [parentId],
            cookie: req,
            updatedColIds: [refTableLinkColumnId],
          });

          await parentBaseModel.broadcastLinkUpdates([parentId]);
        }
        break;
      case RelationTypes.ONE_TO_ONE:
        {
          // 1. check current row is linked with another child
          const linkedCurrentOoRowObj =
            await this.getHmOrOoChildLinkedWithParent();

          if (linkedCurrentOoRowObj) {
            const oldChildRowId = getCompositePkValue(
              childTable.primaryKeys,
              baseModel.extractPksValues(linkedCurrentOoRowObj),
            );

            if (oldChildRowId) {
              await webhookHandler.addAffectedChildId(oldChildRowId);
              const [parentRelatedPkValue, childRelatedPkValue] =
                await baseModel.readOnlyPrimariesByPkFromModel([
                  { model: childTable, id: oldChildRowId },
                  { model: parentTable, id: parentId },
                ]);

              this.auditUpdateObj.push({
                rowId: parentId,
                refRowId: oldChildRowId as string,
                opSubType: AuditOperationSubTypes.UNLINK_RECORD,
                displayValue: parentRelatedPkValue,
                refDisplayValue: childRelatedPkValue,
                direction: 'parent_child',
                type: colOptions.type as RelationTypes,
              });

              this.auditUpdateObj.push({
                rowId: oldChildRowId as string,
                refRowId: parentId,
                opSubType: AuditOperationSubTypes.UNLINK_RECORD,
                displayValue: childRelatedPkValue,
                refDisplayValue: parentRelatedPkValue,
                direction: 'child_parent',
                type: getOppositeRelationType(colOptions.type),
              });
              await childBaseModel.updateLastModified({
                baseModel: childBaseModel,
                model: childTable,
                rowIds: [oldChildRowId],
                cookie: req,
                updatedColIds: [column.id],
              });
            }
          }

          // 2. check current child is linked with another row cell
          const linkedOoRowObj = await this.getHmOrOoChildRow();

          const oldRowId = linkedOoRowObj
            ? linkedOoRowObj[childColumn.column_name]
            : null;
          if (oldRowId) {
            await webhookHandler.addAffectedParentId(oldRowId);
            const [parentRelatedPkValue, childRelatedPkValue] =
              await baseModel.readOnlyPrimariesByPkFromModel([
                { model: childTable, id: childId },
                { model: parentTable, id: oldRowId },
              ]);

            this.auditUpdateObj.push({
              rowId: oldRowId as string,
              refRowId: childId,
              opSubType: AuditOperationSubTypes.UNLINK_RECORD,
              displayValue: parentRelatedPkValue,
              refDisplayValue: childRelatedPkValue,
              direction: 'parent_child',
              type: colOptions.type as RelationTypes,
            });

            this.auditUpdateObj.push({
              rowId: childId,
              refRowId: oldRowId as string,
              opSubType: AuditOperationSubTypes.UNLINK_RECORD,
              displayValue: childRelatedPkValue,
              refDisplayValue: parentRelatedPkValue,
              direction: 'child_parent',
              type: getOppositeRelationType(colOptions.type),
            });
            await parentBaseModel.updateLastModified({
              baseModel: parentBaseModel,
              model: parentTable,
              rowIds: [oldRowId],
              cookie: req,
              updatedColIds: [refTableLinkColumnId],
            });
          }
          // todo: unlink if it's already mapped
          // unlink already mapped record if any
          await childBaseModel.execAndParse(
            baseModel
              .dbDriver(childTn)
              .where({
                [childColumn.column_name]: baseModel.dbDriver.from(
                  baseModel
                    .dbDriver(parentTn)
                    .select(parentColumn.column_name)
                    .where(_wherePk(parentTable.primaryKeys, parentId))
                    .first()
                    .as('___cn_alias'),
                ),
              })
              .update({ [childColumn.column_name]: null }),
            null,
            { raw: true },
          );

          await childBaseModel.execAndParse(
            baseModel
              .dbDriver(childTn)
              .update({
                [childColumn.column_name]: baseModel.dbDriver.from(
                  baseModel
                    .dbDriver(parentTn)
                    .select(parentColumn.column_name)
                    .where(_wherePk(parentTable.primaryKeys, parentId))
                    .first()
                    .as('___cn_alias'),
                ),
              })
              .where(_wherePk(childTable.primaryKeys, childId)),
            null,
            { raw: true },
          );

          await childBaseModel.updateLastModified({
            baseModel: childBaseModel,
            model: childTable,
            rowIds: [childId],
            cookie: req,
            updatedColIds: [column.meta?.bt ? column.id : refTableLinkColumnId],
          });

          await childBaseModel.broadcastLinkUpdates([childId]);

          await parentBaseModel.updateLastModified({
            baseModel: parentBaseModel,
            model: parentTable,
            rowIds: parentId,
            cookie: req,
            updatedColIds: [column.meta?.bt ? refTableLinkColumnId : column.id],
          });

          await parentBaseModel.broadcastLinkUpdates([parentId]);
        }
        break;
    }

    this.auditUpdateObj.push({
      rowId: parentId,
      refRowId: childId,
      opSubType: AuditOperationSubTypes.LINK_RECORD,
      type: colOptions.type as RelationTypes,
      direction: 'parent_child',
    });

    this.auditUpdateObj.push({
      rowId: childId,
      refRowId: parentId,
      opSubType: AuditOperationSubTypes.LINK_RECORD,
      type: getOppositeRelationType(colOptions.type),
      direction: 'child_parent',
    });

    await webhookHandler.finishUpdate();
  }

  async removeChild(params: { req: any }) {
    const {
      relationColumn,
      relationColOptions: colOptions,
      baseModel,
      parentBaseModel,
      parentColumn,
      parentTable,
      parentTn,
      childBaseModel,
      childColumn,
      childTable,
      childTn,

      childId,
      parentId,
      mmContext,
    } = this.relationContext;
    const { req } = params;

    const webhookHandler = await RelationUpdateWebhookHandler.beginUpdate(
      {
        childBaseModel,
        parentBaseModel,
        user: req.user,
        ignoreWebhook: req.query?.ignoreWebhook,
      },
      {
        parent: parentId,
        child: childId,
      },
    );

    const relationType = isMMOrMMLike(relationColumn)
      ? RelationTypes.MANY_TO_MANY
      : colOptions.type;

    switch (relationType) {
      case RelationTypes.MANY_TO_MANY:
        {
          const vChildCol = await colOptions.getMMChildColumn(mmContext);
          const vParentCol = await colOptions.getMMParentColumn(mmContext);
          const vTable = await colOptions.getMMModel(mmContext);
          const assocBaseModel = await Model.getBaseModelSQL(mmContext, {
            model: vTable,
            dbDriver: baseModel.dbDriver,
          });
          const vTn = assocBaseModel.getTnPath(vTable);

          await assocBaseModel.execAndParse(
            baseModel
              .dbDriver(vTn)
              .where({
                [vParentCol.column_name]: baseModel
                  .dbDriver(parentTn)
                  .select(parentColumn.column_name)
                  .where(_wherePk(parentTable.primaryKeys, parentId))
                  .first(),
                [vChildCol.column_name]: baseModel
                  .dbDriver(childTn)
                  .select(childColumn.column_name)
                  .where(_wherePk(childTable.primaryKeys, childId))
                  .first(),
              })
              .delete(),
            null,
            { raw: true },
          );

          await parentBaseModel.updateLastModified({
            baseModel: parentBaseModel,
            model: parentTable,
            rowIds: [parentId],
            cookie: req,
            updatedColIds: [
              (
                await extractCorrespondingLinkColumn(childBaseModel.context, {
                  ltarColumn: this.relationContext.relationColumn,
                  referencedTable: parentTable,
                })
              )?.id,
            ],
          });

          await parentBaseModel.broadcastLinkUpdates([parentId]);

          await childBaseModel.updateLastModified({
            baseModel: childBaseModel,
            model: childTable,
            rowIds: [childId],
            cookie: req,
            updatedColIds: [colOptions.fk_column_id],
          });

          await childBaseModel.broadcastLinkUpdates([childId]);
        }
        break;
      case RelationTypes.HAS_MANY:
        {
          await childBaseModel.execAndParse(
            baseModel
              .dbDriver(childTn)
              // .where({
              //   [childColumn.cn]: this.dbDriver(parentTable.tn)
              //     .select(parentColumn.cn)
              //     .where(parentTable.primaryKey.cn, rowId)
              //     .first()
              // })
              .where(_wherePk(childTable.primaryKeys, childId))
              .update({ [childColumn.column_name]: null }),
            null,
            { raw: true },
          );
          await childBaseModel.updateLastModified({
            baseModel: childBaseModel,
            model: childTable,
            rowIds: [childId],
            cookie: req,
            updatedColIds: [colOptions.fk_column_id],
          });

          await childBaseModel.broadcastLinkUpdates([childId]);

          await parentBaseModel.updateLastModified({
            baseModel: parentBaseModel,
            model: parentTable,
            rowIds: [parentId],
            cookie: req,
            updatedColIds: [
              (
                await extractCorrespondingLinkColumn(childBaseModel.context, {
                  ltarColumn: this.relationContext.relationColumn,
                  referencedTable: parentTable,
                })
              )?.id,
            ],
          });

          await parentBaseModel.broadcastLinkUpdates([parentId]);
        }
        break;
      case RelationTypes.BELONGS_TO:
        {
          await childBaseModel.execAndParse(
            baseModel
              .dbDriver(childTn)
              // .where({
              //   [childColumn.cn]: this.dbDriver(parentTable.tn)
              //     .select(parentColumn.cn)
              //     .where(parentTable.primaryKey.cn, childId)
              //     .first()
              // })
              .where(_wherePk(childTable.primaryKeys, childId))
              .update({ [childColumn.column_name]: null }),
            null,
            { raw: true },
          );

          await childBaseModel.updateLastModified({
            baseModel: childBaseModel,
            model: childTable,
            rowIds: [childId],
            cookie: req,
            updatedColIds: [column.id],
          });

          await childBaseModel.broadcastLinkUpdates([childId]);

          await parentBaseModel.updateLastModified({
            baseModel: parentBaseModel,
            model: parentTable,
            rowIds: [parentId],
            cookie: req,
            updatedColIds: [
              (
                await extractCorrespondingLinkColumn(childBaseModel.context, {
                  ltarColumn: this.relationContext.relationColumn,
                  referencedTable: parentTable,
                })
              )?.id,
            ],
          });

          await parentBaseModel.broadcastLinkUpdates([parentId]);
        }
        break;
      case RelationTypes.ONE_TO_ONE:
        {
          await childBaseModel.execAndParse(
            baseModel
              .dbDriver(childTn)
              .where(_wherePk(childTable.primaryKeys, childId))
              .update({ [childColumn.column_name]: null }),
            null,
            { raw: true },
          );

          await childBaseModel.updateLastModified({
            baseModel: childBaseModel,
            model: childTable,
            rowIds: [childId],
            cookie: req,
            updatedColIds: [colOptions.fk_column_id],
          });

          await childBaseModel.broadcastLinkUpdates([childId]);

          await parentBaseModel.updateLastModified({
            baseModel: parentBaseModel,
            model: parentTable,
            rowIds: [parentId],
            cookie: req,
            updatedColIds: [
              (
                await extractCorrespondingLinkColumn(childBaseModel.context, {
                  ltarColumn: this.relationContext.relationColumn,
                  referencedTable: parentTable,
                })
              )?.id,
            ],
          });
          await parentBaseModel.broadcastLinkUpdates([parentId]);
        }
        break;
    }

    this.auditUpdateObj.push({
      rowId: parentId,
      refRowId: childId,
      opSubType: AuditOperationSubTypes.UNLINK_RECORD,
      type: colOptions.type as RelationTypes,
      direction: 'parent_child',
    });
    if (parentTable.id !== childTable.id) {
      this.auditUpdateObj.push({
        rowId: childId,
        refRowId: parentId,
        opSubType: AuditOperationSubTypes.UNLINK_RECORD,
        type: getOppositeRelationType(colOptions.type),
        direction: 'child_parent',
      });
    }

    await webhookHandler.finishUpdate();
  }

  async handleOnlyUpdateAudit(params: {
    onlyUpdateAuditLogs?: boolean;
    prevData?: Record<string, any>;
    req: any;
  }) {
    const {
      relationColumn: column,
      relationColOptions: colOptions,
      baseModel,
      parentTable,
      childTable,

      childId,
      parentId,
    } = this.relationContext;
    const { prevData } = params;

    const oldChildRowId = prevData[column.title]
      ? getCompositePkValue(
          parentTable.primaryKeys,
          baseModel.extractPksValues(prevData[column.title]),
        )
      : null;

    const [childRelatedPkValue] =
      await baseModel.readOnlyPrimariesByPkFromModel([
        { model: childTable, id: childId },
      ]);

    if (oldChildRowId) {
      this.auditUpdateObj.push({
        rowId: parentId,
        refRowId: oldChildRowId as string,
        opSubType: AuditOperationSubTypes.UNLINK_RECORD,
        displayValue:
          prevData[column.title]?.[parentTable.displayValue.title] ?? null,
        refDisplayValue: childRelatedPkValue,
        direction: 'parent_child',
        type: colOptions.type as RelationTypes,
      });

      this.auditUpdateObj.push({
        rowId: oldChildRowId as string,
        refRowId: parentId,
        opSubType: AuditOperationSubTypes.UNLINK_RECORD,
        displayValue: childRelatedPkValue,
        refDisplayValue:
          prevData[column.title]?.[parentTable.displayValue.title] ?? null,
        direction: 'child_parent',
        type: getOppositeRelationType(colOptions.type),
      });
    }
  }

  getAuditUpdateObj(req: any) {
    const { childTable, parentTable, parentColumn, childColumn } =
      this.relationContext;
    return this.auditUpdateObj.map((log) => {
      const column =
        log.direction === 'parent_child' ? parentColumn : childColumn;
      const refColumn =
        log.direction === 'parent_child' ? childColumn : parentColumn;
      return {
        ...log,
        model: log.direction === 'parent_child' ? parentTable : childTable,
        refModel: log.direction === 'parent_child' ? childTable : parentTable,
        columnTitle: column.title,
        refColumnTitle: refColumn.title,
        columnId: column.id,
        req,
      } as AuditUpdateObj;
    });
  }
}
