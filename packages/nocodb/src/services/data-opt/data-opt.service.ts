import { Injectable } from '@nestjs/common';
import type { Base } from '~/models';
import { Filter, Model, Sort, View } from '~/models';
import {
  _wherePk,
  extractFilterFromXwhere,
  extractSortsObject,
  getListArgs,
} from '~/db/BaseModelSqlv2';
import NcConnectionMgrv2 from '~/utils/common/NcConnectionMgrv2';
import { getAliasGenerator, ROOT_ALIAS } from '~/utils';
import conditionV2 from '~/db/conditionV2';
import sortV2 from '~/db/sortV2';
import { PagedResponseImpl } from '~/helpers/PagedResponse';
import { CacheGetType, CacheScope } from '~/utils/globals';
import NocoCache from '~/cache/NocoCache';
import { extractColumns } from '~/services/data-opt/helpers';
import getAst from '~/helpers/getAst';

@Injectable()
export class DataOptService {
  async list(ctx: {
    model: Model;
    view: View;
    base: Base;
    params;
  }): Promise<PagedResponseImpl<Record<string, any>>> {
    if (ctx.base.type !== 'pg') {
      throw new Error('Single query only supported in postgres');
    }

    let skipCache = false;

    // skip using cached query if sortArr or filterArr is present since it will be different query
    if (
      'sortArr' in ctx.params ||
      'filterArr' in ctx.params ||
      'sort' in ctx.params ||
      'filter' in ctx.params ||
      'where' in ctx.params ||
      'w' in ctx.params ||
      'fields' in ctx.params ||
      'f' in ctx.params ||
      'nested' in ctx.params
    ) {
      skipCache = true;
    }

    const listArgs = getListArgs(ctx.params ?? {}, ctx.model);

    const getAlias = getAliasGenerator();

    // get knex connection
    const knex = await NcConnectionMgrv2.get(ctx.base);

    const cacheKey = `${CacheScope.SINGLE_QUERY}:${ctx.model.id}:${ctx.view.id}`;
    if (!skipCache) {
      const cachedQuery = await NocoCache.get(
        cacheKey,
        CacheGetType.TYPE_STRING,
      );
      if (cachedQuery) {
        const rawRes = await knex.raw(cachedQuery, [
          +listArgs.limit,
          +listArgs.offset,
        ]);

        const res = rawRes?.rows?.[0];

        return new PagedResponseImpl(res.list, {
          count: +res.count,
          limit: +listArgs.limit,
          offset: +listArgs.offset,
        });
      }
    }

    const baseModel = await Model.getBaseModelSQL({
      id: ctx.model.id,
      viewId: ctx.view?.id,
      dbDriver: knex,
    });

    // load columns list
    const columns = await ctx.model.getColumns();

    const rootQb = knex(baseModel.getTnPath(ctx.model));

    const countQb = knex(baseModel.getTnPath(ctx.model));
    countQb.count({ count: ctx.model.primaryKey?.column_name || '*' });

    const aliasColObjMap = await ctx.model.getAliasColObjMap();
    let sorts = extractSortsObject(listArgs?.sort, aliasColObjMap);
    const queryFilterObj = extractFilterFromXwhere(
      listArgs?.where,
      aliasColObjMap,
    );

    if (!sorts?.['length'] && ctx.params.sortArr?.length) {
      sorts = ctx.params.sortArr;
    } else if (ctx.view) {
      sorts = await Sort.list({ viewId: ctx.view.id });
    }

    const aggrConditionObj = [
      new Filter({
        children:
          (await Filter.rootFilterList({
            viewId: ctx.view.id,
          })) || [],
        is_group: true,
      }),
      new Filter({
        children: ctx.params.filterArr || [],
        is_group: true,
        logical_op: 'and',
      }),
      new Filter({
        children: queryFilterObj,
        is_group: true,
        logical_op: 'and',
      }),
    ];

    // apply filters on root query and count query
    await conditionV2(baseModel, aggrConditionObj, rootQb);
    await conditionV2(baseModel, aggrConditionObj, countQb);

    // apply sort on root query
    if (sorts?.length) await sortV2(baseModel, sorts, rootQb);
    // sort by primary key if not autogenerated string
    // if autogenerated string sort by created_at column if present
    else if (ctx.model.primaryKey && ctx.model.primaryKey.ai) {
      rootQb.orderBy(ctx.model.primaryKey.column_name);
    } else if (ctx.model.columns.find((c) => c.column_name === 'created_at')) {
      rootQb.orderBy('created_at');
    }

    const qb = knex.from(rootQb.as(ROOT_ALIAS));

    const allowedCols = null;

    // const tableColumns = await ctx.model.getColumns();
    // if (ctx.view)
    //   allowedCols = (await View.getColumns(ctx.view.id)).reduce((o, c) => {
    //     const column = tableColumns.find((tc) => tc.id === c.fk_column_id);
    //     return {
    //       ...o,
    //       [c.fk_column_id]: column.pk || (c.show && !column?.system),
    //     };
    //   }, {});

    const { dependencyFields } = await getAst({
      query: ctx.params,
      model: ctx.model,
      view: ctx.view,
    });

    await extractColumns({
      columns,
      allowedCols,
      knex,
      qb,
      getAlias,
      dependencyFields,
      params: ctx.params,
      baseModel,
    });

    if (skipCache) {
      rootQb.limit(+listArgs.limit);
      rootQb.offset(+listArgs.offset);
    } else {
      // provide some dummy non-zero value to limit and offset to populate bindings,
      // if offset is 0 then it will ignore bindings
      rootQb.limit(9999);
      rootQb.offset(9999);
    }
    const dataAlias = getAlias();

    const finalQb = knex
      .from(qb.as(dataAlias))
      .select(
        knex.raw(`coalesce(json_agg(??.*),'[]'::json) as ??`, [
          dataAlias,
          'list',
        ]),
      )
      .select(countQb.as('count'))
      .first();

    let res: any;
    if (skipCache) {
      res = await finalQb;
    } else {
      const { sql, bindings } = finalQb.toSQL();

      // bind all params and replace limit and offset with placeholders
      // and in generated sql replace placeholders with bindings
      const query = knex
        .raw(sql, [...bindings.slice(0, -3), '__nc__limit', '__nc__offset', 1])
        .toQuery()
        .replace(
          /\blimit '__nc__limit' offset '__nc__offset'(?!=[\s\S]*limit '__nc__limit' offset '__nc__offset')/i,
          'limit ? offset ?',
        );

      // cache query for later use
      await NocoCache.set(cacheKey, query);

      // run the query with actual limit and offset
      res = (await knex.raw(query, [+listArgs.limit, +listArgs.offset]))
        .rows?.[0];
    }
    return new PagedResponseImpl(res.list, {
      count: +res.count,
      limit: +listArgs.limit,
      offset: +listArgs.offset,
    });
  }

  async read(ctx: {
    model: Model;
    view: View;
    base: Base;
    params;
    id: string;
  }): Promise<PagedResponseImpl<Record<string, any>>> {
    if (ctx.base.type !== 'pg') {
      throw new Error('Single query only supported in postgres');
    }

    let skipCache = false;

    // skip using cached query if  filterArr is present since it will be different query
    if (
      'filterArr' in ctx.params ||
      'filter' in ctx.params ||
      'where' in ctx.params ||
      'fields' in ctx.params ||
      'f' in ctx.params ||
      'nested' in ctx.params
    ) {
      skipCache = true;
    }

    const listArgs = getListArgs(ctx.params ?? {}, ctx.model);

    const getAlias = getAliasGenerator();

    // get knex connection
    const knex = await NcConnectionMgrv2.get(ctx.base);

    // const cacheKey = `${CacheScope.SINGLE_QUERY}:${ctx.model.id}:${ctx.view.id}`;
    // if (!skipCache) {
    //   const cachedQuery = await NocoCache.get(
    //     cacheKey,
    //     CacheGetType.TYPE_STRING,
    //   );
    //   if (cachedQuery) {
    //     const rawRes = await knex.raw(cachedQuery, [
    //       +listArgs.limit,
    //       +listArgs.offset,
    //     ]);
    //
    //     const res = rawRes?.rows?.[0];
    //
    //     return new PagedResponseImpl(res.list, {
    //       count: +res.count,
    //       limit: +listArgs.limit,
    //       offset: +listArgs.offset,
    //     });
    //   }
    // }

    const baseModel = await Model.getBaseModelSQL({
      id: ctx.model.id,
      viewId: ctx.view?.id,
      dbDriver: knex,
    });

    // load columns list
    const columns = await ctx.model.getColumns();

    const rootQb = knex(baseModel.getTnPath(ctx.model));

    rootQb.where(_wherePk(ctx.model.primaryKeys, ctx.id));

    // const countQb = knex(baseModel.getTnPath(ctx.model));
    // countQb.count({ count: ctx.model.primaryKey?.column_name || '*' });

    const aliasColObjMap = await ctx.model.getAliasColObjMap();
    // let sorts = extractSortsObject(listArgs?.sort, aliasColObjMap);
    const queryFilterObj = extractFilterFromXwhere(
      listArgs?.where,
      aliasColObjMap,
    );

    // if (!sorts?.['length'] && ctx.params.sortArr?.length) {
    //   sorts = ctx.params.sortArr;
    // } else if (ctx.view) {
    //   sorts = await Sort.list({ viewId: ctx.view.id });
    // }

    const aggrConditionObj = [
      new Filter({
        children:
          (await Filter.rootFilterList({
            viewId: ctx.view.id,
          })) || [],
        is_group: true,
      }),
      new Filter({
        children: ctx.params.filterArr || [],
        is_group: true,
        logical_op: 'and',
      }),
      new Filter({
        children: queryFilterObj,
        is_group: true,
        logical_op: 'and',
      }),
    ];

    // apply filters on root query and count query
    await conditionV2(baseModel, aggrConditionObj, rootQb);
    // await conditionV2(baseModel, aggrConditionObj, countQb);

    // apply sort on root query
    // if (sorts) await sortV2(baseModel, sorts, rootQb);

    const qb = knex.from(rootQb.as(ROOT_ALIAS));

    let allowedCols = null;

    const tableColumns = await ctx.model.getColumns();

    if (ctx.view)
      allowedCols = (await View.getColumns(ctx.view.id)).reduce((o, c) => {
        const column = tableColumns.find((tc) => tc.id === c.fk_column_id);
        return {
          ...o,
          [c.fk_column_id]: column.pk || (c.show && !column?.system),
        };
      }, {});

    const { dependencyFields } = await getAst({
      query: ctx.params,
      model: ctx.model,
      view: ctx.view,
    });

    await extractColumns({
      columns,
      allowedCols,
      dependencyFields,
      knex,
      qb,
      getAlias,
      params: ctx.params,
      baseModel,
    });

    // const dataAlias = getAlias();

    const finalQb = qb.first();

    // let res: any;
    // if (skipCache) {
    //   res = await finalQb;
    // } else {
    //   const { sql, bindings } = finalQb.toSQL();
    //
    //   // bind all params and replace limit and offset with placeholders
    //   // and in generated sql replace placeholders with bindings
    //   const query = knex
    //     .raw(sql, [...bindings.slice(0, -3), '__nc__limit', '__nc__offset', 1])
    //     .toQuery()
    //     .replace(
    //       /\blimit '__nc__limit' offset '__nc__offset'(?!=[\s\S]*limit '__nc__limit' offset '__nc__offset')/i,
    //       'limit ? offset ?',
    //     );
    //
    //   // cache query for later use
    //   await NocoCache.set(cacheKey, query);
    //
    //   // run the query with actual limit and offset
    //   res = (await knex.raw(query, [+listArgs.limit, +listArgs.offset]))
    //     .rows?.[0];
    // }
    // return new PagedResponseImpl(res.list, {
    //   count: +res.count,
    //   limit: +listArgs.limit,
    //   offset: +listArgs.offset,
    // });

    return await finalQb;
  }
}
